<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="js-2.svg" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Курс по JavaScript</title>
  <script type="module" crossorigin src="/course-js/assets/index-223c833f.js"></script>
  <link rel="stylesheet" href="/course-js/assets/index-a937c891.css">
</head>

<body>
  <div class="mask">
    <div class="loader"></div>
  </div>
  <header class="header">
  <div class="container">
    <div class="header__content">

      <div class="header__logo">
        <img src="js-2.svg" alt="logo">
      </div>

      <div class="header__box">

        <div class="header__menu-btn">
          <div class="menu-btn">
  <label class="hamburger">
    <input type="checkbox">
    <svg viewBox="0 0 32 32">
      <path class="line line-top-bottom"
        d="M27 10 13 10C10.8 10 9 8.2 9 6 9 3.5 10.8 2 13 2 15.2 2 17 3.8 17 6L17 26C17 28.2 18.8 30 21 30 23.2 30 25 28.2 25 26 25 23.8 23.2 22 21 22L7 22">
      </path>
      <path class="line" d="M7 16 27 16"></path>
    </svg>
  </label>
</div>
        </div>
      </div>

      <nav class="nav">
        <div class="nav__box">
          <div class="header__theme-btn">
            <div class="theme-btn">
  <label id="theme-toggle-button">
    <input type="checkbox" id="toggle">
    <svg viewBox="0 0 69.667 44" xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns="http://www.w3.org/2000/svg">
      <g transform="translate(3.5 3.5)" data-name="Component 15 – 1"
        id="Component_15_1">


        <g filter="url(#container)" transform="matrix(1, 0, 0, 1, -3.5, -3.5)">
          <rect fill="#83cbd8" transform="translate(3.5 3.5)" rx="17.5"
            height="35" width="60.667" data-name="container" id="container">
          </rect>
        </g>

        <g transform="translate(2.333 2.333)" id="button">

          <g data-name="sun" id="sun">
            <g filter="url(#sun-outer)"
              transform="matrix(1, 0, 0, 1, -5.83, -5.83)">
              <circle fill="#f8e664" transform="translate(5.83 5.83)" r="15.167"
                cy="15.167" cx="15.167" data-name="sun-outer" id="sun-outer-2">
              </circle>
            </g>
            <g filter="url(#sun)" transform="matrix(1, 0, 0, 1, -5.83, -5.83)">
              <path fill="rgba(246,254,247,0.29)"
                transform="translate(9.33 9.33)"
                d="M11.667,0A11.667,11.667,0,1,1,0,11.667,11.667,11.667,0,0,1,11.667,0Z"
                data-name="sun" id="sun-3"></path>
            </g>
            <circle fill="#fcf4b9" transform="translate(8.167 8.167)" r="7"
              cy="7" cx="7" id="sun-inner"></circle>
          </g>


          <g data-name="moon" id="moon">
            <g filter="url(#moon)" transform="matrix(1, 0, 0, 1, -31.5, -5.83)">
              <circle fill="#cce6ee" transform="translate(31.5 5.83)" r="15.167"
                cy="15.167" cx="15.167" data-name="moon" id="moon-3"></circle>
            </g>
            <g fill="#a6cad0" transform="translate(-24.415 -1.009)"
              id="patches">
              <circle transform="translate(43.009 4.496)" r="2" cy="2" cx="2">
              </circle>
              <circle transform="translate(39.366 17.952)" r="2" cy="2" cx="2"
                data-name="patch"></circle>
              <circle transform="translate(33.016 8.044)" r="1" cy="1" cx="1"
                data-name="patch"></circle>
              <circle transform="translate(51.081 18.888)" r="1" cy="1" cx="1"
                data-name="patch"></circle>
              <circle transform="translate(33.016 22.503)" r="1" cy="1" cx="1"
                data-name="patch"></circle>
              <circle transform="translate(50.081 10.53)" r="1.5" cy="1.5"
                cx="1.5" data-name="patch"></circle>
            </g>
          </g>
        </g>


        <g filter="url(#cloud)" transform="matrix(1, 0, 0, 1, -3.5, -3.5)">
          <path fill="#fff" transform="translate(-3466.47 -160.94)"
            d="M3512.81,173.815a4.463,4.463,0,0,1,2.243.62.95.95,0,0,1,.72-1.281,4.852,4.852,0,0,1,2.623.519c.034.02-.5-1.968.281-2.716a2.117,2.117,0,0,1,2.829-.274,1.821,1.821,0,0,1,.854,1.858c.063.037,2.594-.049,3.285,1.273s-.865,2.544-.807,2.626a12.192,12.192,0,0,1,2.278.892c.553.448,1.106,1.992-1.62,2.927a7.742,7.742,0,0,1-3.762-.3c-1.28-.49-1.181-2.65-1.137-2.624s-1.417,2.2-2.623,2.2a4.172,4.172,0,0,1-2.394-1.206,3.825,3.825,0,0,1-2.771.774c-3.429-.46-2.333-3.267-2.2-3.55A3.721,3.721,0,0,1,3512.81,173.815Z"
            data-name="cloud" id="cloud"></path>
        </g>


        <g fill="#def8ff" transform="translate(3.585 1.325)" id="stars">
          <path transform="matrix(-1, 0.017, -0.017, -1, 24.231, 3.055)"
            d="M.774,0,.566.559,0,.539.458.933.25,1.492l.485-.361.458.394L1.024.953,1.509.592.943.572Z">
          </path>
          <path
            transform="matrix(-0.777, 0.629, -0.629, -0.777, 23.185, 12.358)"
            d="M1.341.529.836.472.736,0,.505.46,0,.4.4.729l-.231.46L.605.932l.4.326L.9.786Z"
            data-name="star"></path>
          <path transform="matrix(0.438, 0.899, -0.899, 0.438, 23.177, 29.735)"
            d="M.015,1.065.475.9l.285.365L.766.772l.46-.164L.745.494.751,0,.481.407,0,.293.285.658Z"
            data-name="star"></path>
          <path transform="translate(12.677 0.388) rotate(104)"
            d="M1.161,1.6,1.059,1,1.574.722.962.607.86,0,.613.572,0,.457.446.881.2,1.454l.516-.274Z"
            data-name="star"></path>
          <path transform="matrix(-0.07, 0.998, -0.998, -0.07, 11.066, 15.457)"
            d="M.873,1.648l.114-.62L1.579.945,1.03.62,1.144,0,.706.464.157.139.438.7,0,1.167l.592-.083Z"
            data-name="star"></path>
          <path transform="translate(8.326 28.061) rotate(11)"
            d="M.593,0,.638.724,0,.982l.7.211.045.724.36-.64.7.211L1.342.935,1.7.294,1.063.552Z"
            data-name="star"></path>
          <path transform="translate(5.012 5.962) rotate(172)"
            d="M.816,0,.5.455,0,.311.323.767l-.312.455.516-.215.323.456L.827.911,1.343.7.839.552Z"
            data-name="star"></path>
          <path transform="translate(2.218 14.616) rotate(169)"
            d="M1.261,0,.774.571.114.3.487.967,0,1.538.728,1.32l.372.662.047-.749.728-.218L1.215.749Z"
            data-name="star"></path>
        </g>
      </g>
    </svg>
  </label>
</div>
          </div>
        </div>

        <ul class="nav__list">
          <li class="nav__item _active">
            <a href="#home" data-link="home">
              Главная
            </a>
          </li>
          <li class="nav__item">
            <a href="#basics" data-link="basics">
              Основы
            </a>
          </li>

          <li class="nav__item">
            <a href="#types" data-link="types">
              Типы
            </a>
          </li>

          <li class="nav__item">
            <a href="#objects" data-link="objects">
              Объекты
            </a>
          </li>

          <li class="nav__item">
            <a href="#functions" data-link="functions">
              Функции
            </a>
          </li>

          <li class="nav__item">
            <a href="#operators" data-link="operators">
              Операторы
            </a>
          </li>

          <li class="nav__item">
            <a href="#func-exp" data-link="func-exp">
              Функциональные выражения
            </a>
          </li>

          <li class="nav__item">
            <a href="#instructions" data-link="instructions">
              Инструкции
            </a>
          </li>

          <li class="nav__item">
            <a href="#arrays" data-link="arrays">
              Массивы
            </a>
          </li>

          <li class="nav__item">
            <a href="#destruct" data-link="destruct">
              Деструктуризация
            </a>
          </li>

          <li class="nav__item">
            <a href="#conditional-instructions" data-link="conditional-instructions">
              Условные инструкции
            </a>
          </li>

          <li class="nav__item">
            <a href="#cycles" data-link="cycles">
              Циклы
            </a>
          </li>

          <li class="nav__item">
            <a href="#modules" data-link="modules">
              Модули
            </a>
          </li>
        </ul>
      </nav>

      <div class="overlay"></div>
    </div>
  </div>
</header>
  <main class="base-layout container-fluid">
    <section class="home page container _page _show" id="home" data-page="home">
  <h1 class="title">Курс Богдана Стащука по JS</h1>
  <p class="text">
    Cсылка на курс: 
    <a
      href="https://www.youtube.com/watch?v=CxgOKJh4zWE&ab_channel=BogdanStashchuk" target="_blank">
      JavaScript - Полный Курс JavaScript Для Начинающих [11 ЧАСОВ]
    </a>
  </p>
  <p class="text">Здесь располагается конспект курса. В других разделах, можно найти интересующие вас темы.</p>
</section>
    <section class="container page _page" id="basics" data-page="basics">
  <h2 class="title">Основы</h2>

  <section class="page__section">
    <h5>Основы JS:</h5>
    <p class="text">Практически все сущности в JS - это объекты.</p>
    <p class="text">Объект - это набор свойств "имя: значение"</p>
    <code class="code">
      <i>// Пример объекта</i>
      {
        visible: true,
        colorDepth: 24,
        title: 'My Image',
        orientation: {
          angle: 0,
          type: 'landscape'
        },
        pixelDepth: 24,
        width: 1440,
      }
    </code>
    <p class="text">Массив - это Объект, Функция - это Объект, <br> Число - это
      Объект*, Строка - это Объект*</p>
    <p class="text">* точнее они ведут себя как объекты</p>
  </section>

  <section class="page__section">
    <h5>Объект console:</h5>
    
    <code class="code">
      <i>// Отображает все свойства объекта</i>
      console.dir();

      <i>// Отображает все свойства объекта в табличном виде</i>
      console.table();
    </code>
  </section>

  <section class="page__section">
    <h5>Выражение:</h5>
    <p class="text">Выражение возвращает значение</p>
    <code class="code">
      <i>// Примеры выражений</i>
      'abc'
      10 
      5 + 2 
      c = 10 
      'Good ' + 'Evening'
      a &#60;= b || c !== d
      myFunction(c, d)

      <i>// Выражения с побочными действиями</i>
      a = 5
      b++
      myFunction(c, d)
    </code>
  </section>

  <section class="page__section">
    <h5>Переменные:</h5>
    <p class="text">Переменные дают возможность повторного доступа к значениям</p>
    <p class="text">Имена переменных:</p>
    <ul class="list">
      <li>
        <span class="bold">PascalCase</span> - так в основном называют типы и классы
      </li>
      <li>
        <span class="bold">DB_PASSWORD</span> - так называют константы, значения этих переменных известны до запуска приложения они постоянны, т.е. константы
      </li>
      <li>
        <span class="bold">camelCase</span> - camelCase нотация используется для всех остальных имён переменных
      </li>
    </ul>
    <p class="text underline">Названия переменных должны быть понятными!</p>
    <p class="text">Объявлять переменные можно при помощи следующих ключевых слов:</p>
    <ul class="list">
      <li><span class="bold">let</span> - es6, это изменяемая переменная</li>
      <li><span class="bold">const</span> - es6, это неизменяемая переменная, константа</li>
      <li><span class="bold">var</span> - устаревшее ключевое слово</li>
    </ul>
    <p class="text underline">Константе нельзя присваивать новые значения и нельзя объявлять её пустой!</p>
    <p class="bold">Объявление и присваивание:</p>
    <code class="code">
      let a <i>// Объявление переменной</i>
      const c = 10 <i>// Объявление и присваивание</i>
      a = true <i>// Только присваивание</i>

      c = 11 <i>// Uncaught TypeError: Assignment to constant variable.</i>
      const b <i>// Uncaught SyntaxError: Missing initializer in const declaration</i>
    </code>

    <code class="code">
      console.log(a) <i>// ReferenceError: a is not defined</i>
      let a
      console.log(a) <i>// undefined</i>

      a = true
      console.log(a) <i>// true</i>
    </code>


  </section>
</section>
    <section class="container page _page" id="types" data-page="types">
  <h2 class="types__title">
    Типы
  </h2>
  <section class="page__section">
    <p class="underline">Тип переменной определяется типом присвоеного
      значения</p>
    <code class="code">
      const a = 10 <i>// number</i>
      const b = 'abc' <i>// string</i>
    </code>
    <p class="text">Переменная => Имеет значение => Значение имеет тип</p>
  </section>

  <section class="page__section">
    <h5>Примитивные типы:</h5>
    <ol class="list-column">
      <li>string (строка)</li>
      <li>boolean (логический)</li>
      <li>number (число)</li>
      <li>null</li>
      <li>undefined</li>
      <li>symbol (символ)</li>
    </ol>
    <p class="text"><span class="bold">null</span> - используется тогда, когда
      вы хотите явно указать, что у какой-либо переменной на данном этапе
      отсутствует значение.</p>
    <p class="text"><span class="bold">undefined</span> - значение у той или
      иной переменной нету, его не существует, оно не определено.</p>
    <p class="text">Разница между <span class="bold">null</span> и <span
        class="bold">undefined</span> в том, что null мы присваиваем сами,
      как-бы явно говоря, что сейчас у этой переменной нет значения, и возможно
      позже оно будет присвоено, но сейчас оно null. Undefined не нужно
      присваивать переменной, когда мы объявляем переменную при помощи let и не
      присваиваем новое значение, то значение этой переменной будет 'undefined'
      (т.е. неопределено).</p>
    <p class="text"><span class="bold">symbol</span> - с помощью этого типа
      можно создавать уникальные значения, используется достаточно редко.</p>
  </section>

  <section class="page__section">
    <h5>Ссылочный тип:</h5>
    <p class="text"><span class="bold">Object (объект)</span></p>
    <p class="text underline">Ссылочный тип в JS только один, и он называется
      объект</p>
    <p class="text">Одна из особенностей в том, что на один объект могут
      ссылаться сразу несколько переменных. Т.к. переменная содержит ссылку на
      объект, а не сам объект. Т.е. несколько переменных могут ссылаться на один
      объект в памяти. Используя разные переменные мы можем менять один и тот же
      объект.</p>
    <code class="code">
      const objectA = {
        a: 10,
        b: true
      }

      const copyOfA = objectA; <i>// Объект остаётся в памяти в одном месте, а ссылка на него копируется с одной переменной в другую переменную</i>

      copyOfA.a = 20; <i>// objectA.a => 20</i>
      <i>// Изменяя copyOfA мы изменяем и objectA, т.к. они являются ссылками на
        один и тот же объект</i>

      copyOfA.c = 'abc'; <i>// Добавление новых свойств в объект</i>
      <i>// Исходный объект тоже изменится objectA.c => 'abc'</i>


    </code>
  </section>

  <section class="page__section">
    <h5>Динамическая типизация:</h5>

    <p class="bold"> Пример статической типизации:</p>
    <code class="code">
      String a = 'abc'
      int b = 10
      b = 'xyz' <i>// Error</i>
    </code>

    <p class="bold">Пример динамической типизации:</p>
    <code class="code">
      let a = true <i>// Boolean</i>
      a = 'abc' <i>// String</i>
      a = 10 <i>// Number</i>
    </code>
    <p class="underline">JavaScript - это динамически типизируемый язык</p>
    <p class="bold">Пример с функцией:</p>
    <code class="code">
      function a() {
        console.log('Hey there');
      }

      a() <i>// 'Hey there'</i>

      a = 10

      a() <i>// Uncaught TypeError: a is not a function</i>
      <i>// Чтобы предотвратить подобную ситуацию, нужно использовать 'const'
        там, где это возможно.</i>
    </code>

    <p class="bold">Const для объявления переменных:</p>
    <p>
      <span class="bold">const</span> - позволяет предотвратить возможные проблемы, связанные с динамической типизацией.
    </p>
    <code class="code">
      const a = () => {
        console.log('Hey there');
      }

      a() <i>// 'Hey there'</i>
      
      a = 10 <i>// Uncaught TypeError: Assignment to constant variable.</i>

      a() <i>// 'Выполнение кода не дойдёт до этой строки'</i>
    </code>
    <p class="bold underline">Правила работы с переменными:</p>
    <ol class="list">
      <li>Все переменные объявлять перед их использованием</li>
      <li>Стараться использовать <span class="underline">const</span> везде, где это возможно</li>
    </ol>
  </section>
</section>
    <section class="container page _page" id="objects" data-page="objects">
  <h2>Объекты</h2>
  <section class="page__section">
    <h4>Общее</h4>
    <p class="text"><b>Объект</b> - это набор свойств "имя: значение"</p>

    <p class="bold">Структура и синтаксис:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
        popular: true,
        country: 'USA'
      }
    </code>
    <p>Порядок свойств в объекте не имеет значения.</p>

    <p class="bold">Получение значений свойств:</p>
    <code class="code">
      console.log(myCity.city) <i>// 'New York'</i>
      console.log(myCity.popular) <i>// 'true'</i>
      <i>// Этот синтаксис называется точечная запись(Dot notation)</i>
    </code>

    <p class="bold">Изменение значений свойств:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
      }

      myCity.city = 'Krasnodar';

      console.log(myCity)
      <i>// {city: 'Krasnodar'}</i>
    </code>

    <p class="bold">Добавление новых свойств:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
      }

      myCity.popular = true;
      console.log(myCity)
      <i>// {city: 'New York', popular: true}</i>

      myCity.country = 'Russia';
      console.log(myCity)
      <i>// {city: 'New York', popular: true, country: 'Russia'}</i>
    </code>

    <p class="bold">Удаление свойств:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
        popular: true,
        country: 'USA'
      }

      delete myCity.country;
      console.log(myCity);
      <i>// {city: 'New York', popular: true}</i>
    </code>

    <p class="bold">Доступ к значению свойства с использованием скобок:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
      }

      myCity['popular'] = true;
      console.log(myCity);
      <i>// {city: 'New York', popular: true}</i>

      const countryPropertyName = 'country';
      myCity[countryPropertyName] = 'USA';

      console.log(myCity);
      <i>// {city: 'New York', popular: true, country: 'USA'}</i>
    </code>

    <p class="bold">Вложенные свойства:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
        info: {
          isPopular: true,
          country: 'USA'
        }
      }

      console.log(myCity.info.isPopular);
      <i>// true</i>

      delete myCity.info['isPopular'];

      console.log(myCity);
      <i>// { city: 'New York', info: { country: 'USA' }}</i>
    </code>

    <p class="bold">Использование переменных:</p>
    <code class="code">
      const name = 'Eugene';
      const postsQty = 32;

      const userProfile = {
        name: name,
        postsQty: postsQty,
        hasSignedAgreement: false
      }
    </code>

    <p class="bold">Сокращенный формат записи свойств:</p>
    <code class="code">
      const name = 'Eugene';
      const postsQty = 32;

      const userProfile = {
        name,
        postsQty,
        hasSignedAgreement: false
      }
    </code>
    <p>Сокращенные свойства рекомендуется размещать в начале объекта</p>
  </section>

  <section class="page__section">
    <h4>Глобальные объекты</h4>
    <p class="text"><b class="bold">window</b> - Веб браузеры</p>
    <p class="text"><b class="bold">global</b> - Node.js</p>
    <p class="text"><b class="bold">globalThis</b> - унифицированный глобальный
      объект</p>
    <p class="text"><b class="bold">console</b> - на самом деле является
      свойством глобальных объектов window или global (window.console,
      global.console)</p>
    <p class="text">
      <span class="underline">window.console.log('Hello') ===
        console.log('Hello')</span>
      <br>Аналогично и для объекта global Node.js
    </p>
  </section>

  <section class="page__section">
    <h4>Методы</h4>

    <p class="text"><b class="bold">Метод</b> - это свойство объекта, которые
      содержат функции. Соответствеено методы как и функции можно вызывать.</p>
    <p class="bold">Пример метода и его вызов:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
        cityGreeting: function () {
          console.log('Greetings!!');
        }
      }

      myCity.cityGreeting();
      <i>// 'Greetings!!'</i>
    </code>

    <p class="bold">Сокращенная форма записи:</p>
    <code class="code">
      const myCity = {
        city: 'New York',
        cityGreeting() {
          console.log('Greetings!!');
        }
      }

      myCity.cityGreeting();
      <i>// 'Greetings!!'</i>

      myCity.city
      <i>// Доступ к значению свойства</i>

      myCity.cityGreeting()
      <i>// Вызов метода</i>
    </code>
  </section>

  <section class="page__section">
    <h4>JSON</h4>
    <p class="bold">JSON - JavaScript Object Notation</p>
    <code class="code">
      {
        "userId": 1,
        "id": 1,
        "title": "Test title",
        "status": {
          "completed": false
        }
      }
    </code>
    <p class="text">По сути это формат обмена данными в интернете. JSON
      передаётся в виде строки</p>

    <p class="bold">Конвертация JSON в объект</p>
    <code class="code">
      JSON.parse()
    </code>

    <p class="bold">Конвертация объекта в JSON</p>
    <code class="code">
      JSON.stringify()
    </code>
  </section>

  <section class="page__section">
    <h4>Мутация в JavaScript</h4>
    <p class="bold">Значения примитивных типов:</p>
    <code class="code">
      const a = 10;

      let b = a;
      <i>// Копирование значения(copy by value)</i>

      b = 30;

      console.log(a);
      <i>// 10</i>

      console.log(b);
      <i>// 30</i>
    </code>

    <p class="bold">Значения ссылочного типа:</p>
    <code class="code">
      const person = {
        name: 'Bob',
        age: 21
      };

      person.age = 22;
      person.isAdult = true;
      <i>// Мутация объекта на который ссылается переменная "person"</i>

      console.log(person.age);
      <i>// 22</i>

      console.log(person.isAdult);
      <i>// true</i>
    </code>

    <p class="bold">Мутирование копий:</p>
    <code class="code">
      const person = {
        name: 'Bob',
        age: 25
      };

      const person2 = person;
      <i>// Копирование ссылки(copy by reference)</i>

      person2.age = 26;
      person2.isAdult = true;

      console.log(person.age);
      <i>// 26</i>
      <i>// Мутация также отразилась и на оригинальном объекте 'person'</i>

      console.log(person.isAdult);
      <i>// true</i>
    </code>
    <br>
    <h4 class="bold">Как избежать мутаций:</h4>
    <p class="text underline">Вариант 1</p>
    <code class="code">
      const person = {
        name: 'Bob',
        age: 25
      };

      const person2 = Object.assign({}, person);
      <i>// Если у объекта есть вложенные объекты, то ссылки на них сохраняются</i>

      person2.age = 26;

      console.log(person2.age);
      <i>// 26</i>

      console.log(person.age);
      <i>// 25</i>
    </code>
    <br>

    <p class="text underline">Вариант 2</p>
    <code class="code">
      const person = {
        name: 'Bob',
        age: 25
      };

      const person2 = {... person}
      <i>// Ссылки на вложенные объекты также сохраняются</i>

      person2.name = 'Alice';

      console.log(person2.name);
      <i>// Alice</i>

      console.log(person.name);
      <i>// Bob</i>
    </code>
    <p>... - spread оператор, или оператор разделения объекта на свойства</p>
    <br>
    <p class="text underline">Вариант 3</p>
    <code class="code">
      const person = {
        name: 'Bob',
        age: 25
      };

      const person2 = JSON.parse(JSON.stringify(person));
      <i>// Ссылки на вложенные объекты НЕ СОХРАНЯЮТСЯ, т.е. получается полностью новый объект с любой вложенностью. Если короче, то происходит глубокое клонирование объекта.</i>

      person2.name = 'Alice';

      console.log(person2.name);
      <i>// Alice</i>

      console.log(person.name);
      <i>// Bob</i>
    </code>
  </section>
</section>
    <section class="container page _page" id="functions" data-page="functions">
  <h2>Функции</h2>
  <p class="text"><b class="bold">Функция</b> - это блок кода, который можно выполнять многократно.</p><br>
  <section class="page__section">
    <p class="text">Пример:</p>
    <code class="code">
      let a = 5;
      let b = 3;

      let c;

      c = a + b;
      console.log(c);
      <i>// 8</i>

      a = 8;
      b = 12;
      
      c = a + b;
      console.log(c);
      <i>// 20</i>
    </code>
    <br>
    <p class="text">У примера выше есть повторяющиеся блоки кода, которые можно оптимизировать, т.е. вынести в функцию:</p>
    <code class="code">
      function sum(a, b) {
        const c = a + b;
        console.log(c);
      }

      sum(5, 3);
      <i>// 8</i>

      sum(8, 12);
      <i>// 20</i>
    </code>
    <br>
    <p class="bold">Функция может быть...</p>
    <ul class="list">
      <li>Именованной</li>
      <li>Анонимной</li>
      <li>Присвоена переменной</li>
      <li>Аргументом при вызове другой функции</li>
      <li>Значением свойства объекта(т.е. методом объекта)</li>
    </ul>
    <p class="text">Функция - это объект. В этом можно удостовериться передав функцию в метод дир объекта консоль: <b class="bold">console.dir(myFn)</b>. И попробовать обратиться к свойствам отображаемого объекта.</p>
    <p>Функция возвращает <span class="underline">undefined</span> если нет инструкции <span class="underline">return</span>.</p>
    <br>
    <p class="bold">Вызов функции:</p>
    <code class="code">
      <i>// a, b - это параметры</i>
      function myFn(a, b) {
        let c;
        a = a + 1;
        c = a + b;
        return c;
      }

      <i>// 10, 3 - это аргументы</i>
      myFn(10, 3);
      <i>// 14</i>
    </code>
    <p class="underline">Рассмотрим подробнее:</p>
    <ol class="list">
      <li>Параметрам 'a' и 'b' присваиваются значения 10 и 3</li>
      <li>Объявляется переменная 'c'</li>
      <li>Значение 'a' увеличивается на 1</li>
      <li>Сумма значений 'a' и 'b' присваивается 'c'</li>
      <li>Возвращается значение 'c'</li>
    </ol>
    <br>
    <p class="bold">Самая короткая функция:</p>
    <code class="code">
      function myFn() {}

      myFn();
      <i>// undefined</i>
    </code> 
    <br>
    <p class="bold">Передача значения по ссылке:</p>
    <code class="code">
      const personOne = {
        name: 'Bob',
        age: 21
      }
  
      <i>// Функция мутирует внешний объект</i>
      function increasePersonAge(person) {
        person.age += 1;
        return person;
      }
  
      increasePersonAge(personOne);
      <i>// Передача объекта по ссылке</i>
  
      console.log(personOne.age);
      <i>// 22</i>
    </code>
    <p class="underline">Внутри функции не рекомендуется мутировать внешние объекты</p>
    
    <br>
    <p class="bold">Создание копии объекта:</p>
    <code class="code">
      const personOne = {
        name: 'Bob',
        age: 21
      }

      function increasePersonAge(person) {
        const updatedPerson = Object.assign({}, person);
        updatedPerson.age += 1;
        return updatedPerson;
      }

      const updatedPersonOne = increasePersonAge(personOne);
      console.log(personOne.age);
      <i>// 21</i>
      console.log(updatedPersonOne);
      <i>// 22</i>
      <i>// Объект "personOne" не изменился</i>
    </code>
  </section>

  <section class="page__section">
    <h4>Колбэк функции</h4>
    <code class="code">
      function anotherFunction() {
        <i>// Действия...</i>
      }

      <i>// В теле этой функции вызывается колбэк функция</i>
      function fnWithCallback(callbackFunction) {
        callbackFunction();
      }

      fnWithCallback(anotherFunction);
    </code>
    <br>
    <p class="bold">Пример:</p>
    <code class="code">
      function printMyName() {
        console.log('Eugene');
      }

      setTimeout(printMyName, 1000);
      <i>// Функция "printMyName" будет вызвана через 1000 миллисекунд</i>
    </code>
    <br>
    <p class="underline">Правила работы с функциями:</p>
    <ol class="list">
      <li>Называть функции исходя из выполняемых задач</li>
      <li>Одна функция должна выполнять одну задачу</li>
      <li>Не рекомендуется изменять внешние относительно функции переменные. Т.е. функция должна быть чистой - это означает, что функция работает только с переменными объявлеными внутри неё и не меняет внешние переменные.</li>
    </ol>
  </section>
  
  <br>

  <section class="page__section">
    <h4>Области видимости</h4>
    <p class="text"><b class="bold">Область видимости</b> - определяет границы действия переменной.</p>
    <p class="text">Область видимости может быть глобальной и локальной.</p>
    <br>
    <p class="bold">Пример действия глобальной и локальной области видимости:</p>
    <code class="code">
      let a;
      let b;

      function myFn() {
        let b;
        a = true;
        b = 10;
        consoe.log(b);
        <i>// 10</i>
      }

      myFn();

      console.log(a)
      <i>// true</i>
      console.log(b);
      <i>// undefined</i>
    </code>
    <br>

    <p class="bold">Цепочка областей видимости:</p>
    <code class="code">
      const a = 5;

      function myFn() {
        function innerFn() {
          console.log(a);
          <i>// 5</i>
        }
        innerFn();
      }

      myFn();
    </code>
    <br>
    <hr>
    <p class="bold">Жизненный цикл переменных:</p>
    <code class="code">
      let a;
      let b;
      <i>// 1</i>

      function myFn() {
        let b;
        <i>// 3</i>
        a = true;
        b = 10;
        <i>// 4</i>
        consoe.log(b);
        <i>// 5</i>
      }

      myFn();
      <i>// 2</i>

      console.log(a)
      <i>// true</i>
      console.log(b);
      <i>// undefined</i>
      <i>// 6</i>
    </code>
    <ol class="list">
      <li>Объявление <span class="underline">b</span> в глобальной области видимости. Её значение <span class="underline">undefined</span></li>
      <li>Вызов функции myFn</li>
      <li>Объявление <span class="underline">b</span> в зоне видимости функции myFn</li>
      <li>Объявлена ли <span class="underline">b</span> в рамках функции? Да, присвоение этой переменной <span class="underline">b</span> значения 10</li>
      <li><span class="underline">b</span> имеет значение 10 в области видимости функции</li>
      <li><span class="underline">b</span> всё так же имеет значение <span class="underline">undefined</span> в глобальной области видимости</li>
    </ol>
    <hr>
    <br>
    <b class="bold">Типы областей видимости:</b>
    <ul class="list">
      <li>Глобальная область видимости</li>
      <li>Область видимости функции</li>
      <li>Область видимости блока*</li>
    </ul>
    <p>* переменные, объявленные с помощью <span class="underline">let</span> или <span class="underline">const</span> внутри блока имеют область видимости, ограниченную этим блоком.</p>
    <br>
    <p class="bold">Необъявленные переменные:</p>
    <p class="underline">Внимание! Плохой код, так делать не рекомендуется!</p>
    <code class="code">
      function myFn() {
        a = true;
        console.log(a);
        <i>// true</i>
      }

      myFn();
      console.log(a);
      <i>// true</i>
    </code>
    <p class="text">Переменная <span class="underline">a</span> будет автоматически объявлена в глобальной облатси видимости</p>
    <br>
    <p class="underline">Правила работы с переменными:</p>
    <ol class="list">
      <li>Все переменные объявлять перед их использованием</li>
      <li>Стараться использовать <span class="underline">const</span> везде, где это возможно</li>
      <li>Внутри функций не изменять переменные с внешних областей видимости</li>
    </ol>
    <br>
    <p class="bold">Строгий режим:</p>
    <p class="text"><b class="bold">'use strict'</b> - это инструкция интерпретатору JS анализировать ваш код более пристально. Для того, чтобы включить строгий режим, достаточно добавить строку 'use strict' в самом верху программы. Пример:</p>
    <code class="code">
      'use strict'
      <i>// Эта строка должна быть первой в глобальной области видимости или в области видимости функции</i>

      function myFn() {
        a = true;
        <i>// Uncaught ReferenceError: a is not defined at myFn</i>
      }

      myFn();

      console.log(a);

      <i>// Запрещает использование необъявленных переменных</i>
    </code>
  </section>

</section>
    <section class="container page _page" id="operators" data-page="operators">
  <h2 class="title">Операторы</h2>
  <section class="page__section">
    <p class="text"><b class="bold">Оператор</b> - это встроенная в JS функция.
      Операторы бывают:</p>
    <p class="bold">Арифметические:</p>
    <code class="code">
      +, -, *, /
    </code>

    <p class="bold">Сравнения:</p>
    <code class="code">
      ===, !==, &#60;=, &#62;=
    </code>

    <p class="bold">Логические:</p>
    <code class="code">
      !, &&, ||
    </code>

    <p class="bold">Присваивания:</p>
    <code class="code">
      =
    </code>

    <p class="bold">Текстовые операторы:</p>
    <code class="code">
      typeof, instanceof, new, delete
    </code>

    <p class="bold">Операнды:</p>
    <code class="code">
      a = 10;
      <i>// "a" и "10" - это операнды или аргументы.</i>
      <i>// "=" - это оператор.</i>
    </code>
  </section>
  <br>

  <section class="page__section">
    <h5>Унарные операторы</h5>
    <p class="text">У унарных операторов всегда только один операнд(аргумент).
    </p>
    <code class="code">
      a++;
      +a;
      delete obj.a;
      typeof a;
      new Object();
    </code>
  </section>

  <section class="page__section">
    <h5>Бинарные операторы</h5>
    <p class="text">У бинарных операторов два операнда(аргумента).</p>
    <code class="code">
      a = 5;
      a + b;
      a += 5;
      a === b;
      a && b;
    </code>
  </section>
  <br>
  <section class="page__section">
    <h5>Виды записи:</h5>
    <p class="text"><b class="bold">Инфиксная</b> - в таком формате оператор
      находится между операндами</p>
    <code class="code">
      a = true;
      a + b;
      a += 5;
      a || b;
      a > b;
    </code>
    <p class="text"><b class="bold">Префиксная</b> - оператор находится перед
      операндом.</p>
    <code class="code">
      ++a;
      delete obj.a;
      typeof a;
    </code>

    <p class="text"><b class="bold">Постфиксная запись</b> - оператор находится
      после операнда.</p>
    <code class="code">
      a++;
      myFunction();
    </code>
  </section>
  <br>
  <section class="page__section">
    <h5>Приоритетность операторов:</h5>
    <code class="code">
      a + b * c / d - e;
      a + ((b * c) / (d - e));
      (((a + b) * c) / d) - e;
      <i>// Менять приоритетность можно группировкой с помощью круглых
        скобок</i>
    </code>
  </section>

  <section class="page__section">
    <h5>Логические операторы:</h5>
    <p class="text"><b class="bold">!</b> - логическое отрицание(Не). Всегда
      возвращает булево значение(либо true, либо false).</p>
    <p class="text"><b class="bold">&&</b> - логическое "И"(И).</p>
    <p class="text"><b class="bold">||</b> - логическое "ИЛИ"(ИЛИ).</p>
    <p class="text"><span class="bold">&&, ||</span> - возвращают значение
      одного из операндов.</p>

    <code class="code">
      <i>// Ложные значения:</i>
      false
      0
      ''
      undefined
      null
    </code>
    <br>
    <br>
    <p class="text"><b class="bold">оператор !</b> чаще всего используется в
      условных конструкциях.</p>
    <p class="bold">Примеры с оператором !:</p>
    <code class="code">
      !10 <i>// false</i>
      !0 <i>// true</i>
      !'abc' <i>// false</i>
      !'' <i>// true</i>
      !true <i>// false</i>
      !undefined <i>// true</i>
    </code>

    <p class="bold">Отрицание отрицания !!:</p>
    <code class="code">
      !!10 <i>// true</i>
      !!0 <i>// false</i>
      !!'abc' <i>// true</i>
      !!'' <i>// false</i>
      !!true <i>// true</i>
      !!undefined <i>// false</i>
    </code>
    <p class="text"><b class="bold">оператор !!</b> - позволяет проверить
      ложность значения</p>
    <br>
    <p class="text"><b class="bold">&&</b> - возвращает первое ложное
      значение(Если хотя бы один операнд false, то всё выражение вернёт false)
    </p>

    <p class="text"><b class="bold">&&</b> - возвращает первое истинное
      значение(Если хотя бы один операнд true, то всё выражение вернёт true)
    </p>
  </section>

  <br>

  <section class="page__section">
    <h5>Оператор разделения объекта на свойства ...</h5>
    <p class="text">Оператор <b class="bold underline">...</b></p>
    <code class="code">
      const button = {
      width: 200,
      text: 'Buy'
      }

      const redButton = {
      ...button,
      color: 'red',
      }

      console.table(redButton);
      <i>// {width: 200, text: 'Buy', color: 'red'}</i>
    </code>
    <p class="text">Если у объекта <span class="underline">button</span> есть
      свойство <span class="underline">color</span>, его значение будет
      перезаписано.</p>
    <p class="text">Если вы хотите перезаписывать те или иные свойства объекта,
      то необходимо оператор <b class="bold underline">...</b> использовать в
      начале нового объекта.</p>
    <br>
    <p class="bold">Объединение объектов с помощью <span
        class="underline">...</span></p>
    <code class="code">
      const buttonInfo = {
      text: 'Buy'
      }

      const buttonStyle = {
      color: 'yellow',
      width: 200,
      height: 300
      }

      const button = {
      ...buttonInfo,
      ...buttonStyle
      }

      console.table(button);
    </code>
  </section>

  <section class="page__section">
    <h5>Конкатенация строк</h5>
    <code class="code">
      const hello = 'Hello';
      const world = 'World';

      const greeting = hello + ' ' + world;
    </code>
    <p class="bold">Шаблонные строки:</p>
    <code class="code">
      const hello = 'Hello';
      const world = 'World';

      const greeting = `${hello} ${world}`;

      const myName = 'Eugene';
      const myCity = 'Krasnodar';

      const str = `Меня зовут ${myName} и я живу в ${myCity}`;
      console.log(str);
    </code>
  </section>

</section>
    <section class="container page _page" id="func-exp" data-page="func-exp">
  <h2 class="types__title">
    Функциональные выражения
  </h2>
  <section class="page__section">
    <p class="underline"></p>
    <code class="code">
      <i>// Объявленная функция</i>
      function myFn(a, b) {
        let c;
        a = a + 1;
        c = a + b;
        return c;
      }

      <i>// Функциональное выражение</i>
      function (a, b) {
        let c;
        a = a + 1;
        c = a + b;
        return c;
      }
    </code>
    <p class="text">Функциональные выражения всегда <span
        class="underline">анонимны</span></p>
    <div class="table">
      <table>
        <tr>
          <th></th>
          <th>Объявленная функция</th>
          <th>Функциональное выражение</th>
        </tr>
        <tr>
          <td>Имеет имя</td>
          <td class="yes">Да</td>
          <td class="no">Нет</td>
        </tr>
        <tr>
          <td>Можно использовать автономно</td>
          <td class="yes">Да</td>
          <td class="no">Нет</td>
        </tr>
        <tr>
          <td>Можно присваивать переменной</td>
          <td class="yes">Да</td>
          <td class="yes">Да</td>
        </tr>
        <tr>
          <td>Можно использовать как аргумент в вызове другой функции</td>
          <td class="yes">Да</td>
          <td class="yes">Да</td>
        </tr>
      </table>
    </div>
    <br>
    <p class="bold">Присваивание функционального выражения переменной:</p>
    <code class="code">
      const myFunction = function(a, b) {
        let c;
        a = a + 1;
        c = a + b;
        return c;
      }

      myFunction(5, 3);
      <i>// 9</i>
    </code>
    <br>
    <p class="bold">Функциональное выражение в вызове другой функции:</p>
    <code class="code">
      setTimeout(function() {
      console.log('Отложенное сообщение')
      }, 1000)
      // <i>// Отложенное сообщение будет выведено в консоль через 1000 мс(1
        сек)</i>
    </code>

    <p class="bold">Стрелочные функции:</p>
    <code class="code">
      (a, b) => {
        let c;
        a = a + 1;
        c = a + b;
        return c;
      }
    </code>
    <p class="text">Стрелочная функция - это выражение</p>
    <p class="text">Стрелочные функции - всегда анонимные(нет имени).</p>
    <br>
    <p class="bold">Имя стрелочной функции:</p>
    <code class="code">
      const myFunction = (a, b) => {
        let c;
        a = a + 1;
        c = a + b;
        return c;
      }

      myFunction(5, 3);
      <i>// 9</i>
    </code>
    <p class="text"><span class="underline">Почему не стоит использовать
        традиционную функцию, а лучше присваивать функцию или функциональное
        выражение переменной?</span> <br>
      <b class="bold">Ответ:</b> Всё дело в том, что если объявлять переменную
      при помощи ключевого слова <span class="underline">const</span>, то мы не
      можем присвоить новое значение этой переменной. Т.е., по сути мы
      предотвращаем ситуацию присвоения нового значения переменной, которая
      содержит функцию.
    </p>
    <p class="bold">Стрелочная функция в вызове другой функции:</p>
    <code class="code">
      setTimeout(() => {
        console.log('Выведется через 1 секунду')
      }, 1000);
    </code>
    <p class="bold">Сокращения в стрелочных функциях:</p>
    <code class="code">
      <i>// Если один параметр, то круглые скобки можно опустить</i>
      a => {
        <i>// Тело функции</i>
      }
      
      <i>// Фигурные скобки можно опустить, если тело функции состоит из одного выражения</i>
      (a, b) => a + b
      <i>// В этом случае стрелочная функция неявно возвращает результат выражения</i>
    </code>
  </section>

  <br>

  <section class="page__section">
    <h4>Значения параметров функции по умолчанию:</h4>
    <p class="bold">Пример 1</p>
    <code class="code">
      function multByFactor(value, multiplier = 1) {
        return value * multiplier;
      }

      multByFactor(10, 2)
      <i>// 20</i>
      multByFactor(5)
      <i>// 5</i>
    </code>
    <br>
    <p class="bold">Пример 2</p>
    <code class="code">
      <i>// Значения по умолчанию вычисляются в момент вызова функции</i>
      const newPost = (post, addedAt = Date()) => ({
        ...post, 
        addedAt
      });

      const firstPost = {
        id: 1,
        author: 'Eugene'
      }

      newPost(firstPost);
    </code>
  </section>

  <br>

  <section class="page__section">
    <h4>Обработка ошибок:</h4>
    <p class="bold">Пример необработанной непойманной ошибки(uncaught error):</p>
    <code class="code">
      const fnWithError = () => {
        throw new Error('Some error');
      }

      fnWithError(); <i>// Выполнение кода остановится после появления Uncaught ошибки</i>

      console.log('Continue...');
    </code>
    <br>
    <p class="bold">Блок try/catch</p>
    <code class="code">
      try {
        <i>// Выполнение блока кода</i>
      } catch (error) {
        <i>// Этот блок выполнится в случае возникновения ошибок в блоке try</i>
      }
    </code>
    <p class="bold">Пример оборачивания кода в try/catch</p>
    <code class="code">
      const fnWithError = () => {
        throw new Error('Some error')
      }
      
      try {
        fnWithError();
      } catch(error) {
        console.error(error);
        console.log(error.message);
      }

      console.log('Continue...'); <i>// Выполнение кода продолжится</i>
    </code>
  </section>
</section>
    <section class="container page _page" id="instructions"
  data-page="instructions">
  <h2>
    Инструкции
  </h2>
  <section class="page__section">
    <p class="text">
      <span class="bold">Выражение</span> - возвращает значение. <br>
      <span class="bold">Инструкция</span> - не возвращает значение, она
      выполняет определённые действия. <br>
      <span class="underline">Выражение может быть инструкцией.</span>
    </p>
    <br>
    <p class="bold">Примеры инструкций:</p>
    <code class="code">
      let a;

      const b = 5;

      if(a > b) {
      console.log('a is larger');
      }

      for (let i = 0; i &#60; 5; i++) {
      console.log(i);
      }
      <i>// После закрывающей фигурной скобки не требуется точка с запятой</i>
    </code>
    <p class="underline">Инструкция обычно заканчивается точкой с запятой. <br>
      Исключение: Точка с запятой не требуется после блока инструкций.
    </p>
    <br>
    <p class="bold">Примеры выражений-инструкций:</p>
    <code class="code">
      'abc';

      a = a + 3;

      c = a + b;

      d = 'Good' + 'Evening';

      myFunc(c, d);

      console.log('Hey nigers!');
      <i>// После закрывающей фигурной скобки не требуется точка с запятой</i>
    </code>
    <p class="underline">Инструкция не может быть трансформирована в выражение.
    </p>
    <br>
    <p class="bold">Как отличить выражение от инструкций?</p>
    <p class="underline">Выражения могут быть использованы как аргументы в
      вызовах функций.<br>Соответственно инструкции не могут быть использованы
      как аргументы в вызовах функций.
    </p>
    <code class="code">
      function myFn(a) {
        console.log(a);
      }

      const b = true;
      let c = 10;

      myFn(2 + 3); <i>// 5</i>
      myFn(b); <i>// true</i>
      myFn(c = c + 1); <i>// 11</i>
      myFn(c = c + 1;) <i>// Uncaught SyntaxError; Точка с запятой конвертирует выражение в инструкцию и мы получаем ошибку.</i>
      myFn(let d) <i>// Uncaught SyntaxError</i>
    </code>
    <p class="underline">Если вы хотите проверить что есть инструкция, а что выражение, то можно передать аргументом то, что вы хотите проверить в любую функцию. Инструкцию нельзя передать аргументом в вызов функции, поэтому будет ошибка. Выражение - можно, оно всегда возвращает значение.</p>

  </section>
</section>
    <section class="container page _page" id="arrays" data-page="arrays">
  <h2>
    Массивы
  </h2>

  <section class="page__section">
    <p class="text underline"><b class="bold">Массив</b> - это объект с
      цифровыми именами свойств</p>
    <br>
    <p class="bold">Формат записи массивов:</p>
    <code class="code">
      const myArray = [1, 2, 3];
      console.log(myArray); <i>// [1, 2, 3]</i>

      const myArray2 = new Array(1, 2, 3);
      console.log(myArray2); <i>// [1, 2, 3]</i>
    </code>
    <br>
    <p class="bold">Массив VS объект</p>
    <code class="code">
      const myObject = {
      0: 1,
      1: 2,
      2: 3,
      length: 3
      }

      const myArray = [1, 2, 3];

      console.log(myObject); <i>// {0: 1, 1: 2, 2: 3, length: 3}</i>
      console.log(myArray); <i>// [1, 2, 3]</i>
    </code>
    <div class="img">
      <img src="/course-js/assets/arrays-3f6b98c1.webp" alt="array vs object">
    </div>
    <br>
    <p class="bold">Чтение значений массива:</p>
    <code class="code">
      const myArray = [1, true, 'a'];
      console.log(myArray); <i>// [1, true, 'a']</i>

      console.log(myArray[0]); <i>// 1</i>
      console.log(myArray[1]); <i>// true</i>

      console.log(myArray.length); <i>// 3</i>
    </code>
    <p class="underline">Порядок элементов в массиве ВАЖЕН, т.к. каждый элемент
      в массиве имеет свой порядковый номер - он называется индексом.</p>
    <br>
    <p class="bold">Длина массива:</p>
    <code class="code">
      const myArray = [1, 2, 3, 4];
      console.log(myArray); <i>// [1, 2, 3, 4]</i>
      console.log(myArray.length); <i>// 4</i>

      myArray[2] = 'abc';

      console.log(myArray); <i>// [1, 2, 'abc', 4]</i>
      console.log(myArray[2]); <i>// 'abc'</i>

      myArray[4] = true;

      console.log(myArray); <i>// [1, 2, 'abc', 4, true]</i>
      console.log(myArray.length); <i>// 5</i>
    </code>
    <br>
    <h4 class="bold">Методы массивов:</h4>
    <p class="underline">Методы массива - называются функциями высшего порядка в
      массивах, либо функциями прототипов, либо методами прототипов.</p>
    <div class="img">
      <img src="/course-js/assets/arrays-1-41e7666d.webp" alt="Функции высшего порядка">
    </div>
    <br>
    <p class="bold">Метод push:</p>
    <p class="underline">Добавляет элемент в конец массива</p>
    <code class="code">
      const myArray = [1, 2, 3];
      console.log(myArray); // <i>[1, 2, 3]</i>

      myArray.push(4)
      console.log(myArray); // <i>[1, 2, 3, 4]</i>

      myArray.push(true);
      console.log(myArray); // <i>[1, 2, 3, 4, true]</i>
    </code>
    <br>
    <p class="bold">Метод pop:</p>
    <p class="underline">Удаляет последний элемент массива и возвращает его</p>
    <code class="code">
      const myArray = [1, 2, 3];
      console.log(myArray); // <i>[1, 2, 3]</i>

      myArray.pop();
      console.log(myArray); // <i>[1, 2]</i>

      const removedElement = myArray.pop(); // <i>Метод pop возвращает удалённый
        элемент массива, соответственно его можно присвоить переменной</i>
      console.log(myArray); // <i>[1]</i>
      console.log(removedElement); // <i>2</i>
    </code>
    <br>
    <p class="bold">Метод unshift:</p>
    <p class="underline">Добавляет элемент в начало массива</p>
    <p class="text">Используется редко, т.к. сдвигает индексы элементов массива.
    </p>

    <code class="code">
      const myArray = [1, 2, 3];
      console.log(myArray); // <i>[1, 2, 3]</i>

      myArray.unshift(true);
      console.log(myArray); // <i>[true, 1, 2, 3]</i>

      myArray.unshift('abc');
      console.log(myArray);
    </code>
    <br>
    <p class="bold">Метод shift:</p>
    <p class="underline">Удаляет первый элемент массива и возвращает его</p>
    <p class="text">Тоже сдвигает индексы у элементов массива.</p>

    <code class="code">
      const myArray = [1, 2, 3];
      console.log(myArray); // <i>[1, 2, 3]</i>

      myArray.shift();
      console.log(myArray); // <i>[2, 3]</i>

      const removedElement = myArray.shift();

      console.log(myArray); // <i>[3]</i>
      console.log(removedElement); // <i>2</i>
    </code>
    <p class="text">Нужно учитывать, что все эти методы: push, pop,
      unshift, shift - мутируют, т.е. изменяют оригинальный массив.</p>

      <br>
      <p class="bold">Метод forEach:</p>
      <p class="underline">Перебирает все элементы массива, и для каждого элемента массива вызывает callback-функцию, в которую параметром передаётся значение определённого элемента массива.</p>
  
      <code class="code">
        const myArray = [1, 2, 3];
        console.log(myArray); // <i>[1, 2, 3]</i>
  
        myArray.forEach(el => console.log(el * 2));
        console.log(myArray); // <i>[1, 2, 3] - оригинальный массив не изменился.</i>
      </code>

      <br>
      <p class="bold">Метод map:</p>
      <p class="underline">Этот метод, как и forEach - перебирает массив и для каждого элемента вызывает callback-функцию, но в отличие от forEach он возвращает новый массив.</p>
  
      <code class="code">
        const myArray = [1, 2, 3];
        console.log(myArray); // <i>[1, 2, 3]</i>
  
        const newArray = myArray.map(el => el * 3);
        console.log(newArray); // <i>[3, 6, 9]</i>
        console.log(myArray); // <i>[1, 2, 3] - Оригинальный массив не изменился</i>
      </code>
  </section>
</section>
    <section class="container page _page" id="destruct" data-page="destruct">
  <h2>
    Деструктуризация
  </h2>
  <section class="page__section">
    <p class="bold">Деструктуризация объектов:</p>
    <code class="code">
      const userProfile = {
        name: 'Eugene',
        commentsQty: 25,
        hasSignedAgreement: false,
      }

      const { name, commentsQty } = userProfile;
      const { hasSignedAgreement } = userProfile;
      // <i>Эти два выражения в примере равносильны этому одному: const { name, commentsQty, hasSignedAgreement } = userProfile; </i>

      console.log(name); // <i>Eugene</i>
      console.log(commentsQty); // <i>25</i>
    </code>
    <p class="text">Объявление новых переменных и присваивание значений на основе значений свойств объекта</p>
    <p class="text">Эти два выражения в примере равносильны этому одному: 
      <span class="underline">
        const { name, commentsQty, hasSignedAgreement } = userProfile;
      </span>
    </p>
    <br> 
    <p class="bold">Деструктуризация массивов:</p>
    <code class="code">
      const fruits = ['Apple', 'Banana', 'Cherry'];

      const [fruitOne, fruitTwo] = fruits;

      console.log(fruitOne); // <i>Apple</i>
      console.log(fruitTwo); // <i>Banana</i>
    </code>
    
    <p class="underline">
      При деструктуризации массива важен порядок объявляемых переменных, при деструктуризации объекта он неважен
    </p>
    <br>
    <p class="bold">Деструктуризация в функциях</p>
    <code class="code">
      const userProfile = {
        name: 'Eugene',
        commentsQty: 23,
        hasSignedAgreement: false,
      }

      const userInfo = ({name, commentsQty}) => {
        if(!commentsQty) {
          return `User ${name} has no comments`;
        }

        return `User ${name} has ${commentsQty} comments`;
      }

      userInfo(userProfile); //<i>'User Eugene has 1 comments'</i>
    </code>
  </section>
</section>
    <section class="container page _page" id="conditional-instructions" data-page="conditional-instructions">
  <h2>
    Условные инструкции
  </h2>
  <section class="page__section">
    <h3>Виды условных инструкций:</h3>
    <ol class="list">
      <li>if</li>
      <li>if ... else</li>
      <li>switch</li>
      <li>тернарный оператор</li>
    </ol>
    <br>
    <h5>Инструкция if:</h5>
    <code class="code">
      if(Условие) {
        // <i>Блок кода, выполняемый однократно, если Условие правдиво</i>
      }
    </code>
    <br>
    <p class="bold">Пример if:</p>
    <code class="code">
      let val = 10;

      if(val > 5) {
        val += 20; 
      }
      
      console.log(val); // <i>30</i>
    </code>
    <br>
    <p class="bold">Пример if с оператором отрицания:</p>
    <code class="code">
      const person = {
        age: 30, 
      }

      if(!person.name) { 
        console.log('Имя не указано'); 
        // <i>Другие действия в случае, если свойства "name" у объекта "person" нету</i>
      }
    </code>
    <br>
    <h5 class="bold">Пример инструкции if else:</h5>
    <code class="code">
      if(Условие) { 
        // <i>Блок кода, выполняемый однократно, если Условие правдиво</i>
      } else {
        // <i>Блок кода, выполняемый однократно, если Условие ложно</i>
      }
    </code>
    <br>
    <p class="bold">Пример if else:</p>
    <code class="code">
      let val = 10;

      if(val &#60; 5) {
        val += 20;
      } else {
        val -= 20;
      }

      console.log(val); // <i>-10</i> 
    </code>
    <br>
    <p class="bold">Инструкция if else if:</p>
    <code class="code">
      if(Условие 1) {
        // <i>Блок кода, выполняемый однократно, если Условие 1 правдиво</i>
      } else if(Условие 2) {
        // <i>Блок кода, выполняемый однократно, если Условие 2 правдиво</i>
      } else {
        // <i>Блок кода, выполняемый однократно, если предыдущие условия ложны</i>
      }
    </code>
    <br>
    <p class="bold">Предпочтительный формат if:</p>
    <code class="code">
      if(Условие 1) {
        // <i>Блок кода, выполняемый однократно, если Условие 1 правдиво</i>
      } 

      if(Условие 2) {
        // <i>Блок кода, выполняемый однократно, если Условие 2 правдиво</i>
      }
      
      if(Условие 3) {
        // <i>Блок кода, выполняемый однократно, если Условие 3 правдиво</i>
      }
    </code>
    <br>
    <p>Разница между двумя форматами написания:</p>
    <code class="code">
      const age = 25;
      // <i>Первый формат:</i>
      if(age > 18) {
        console.log('Is adult');
      } else if(age >= 12) {
        console.log('Is teenager');
      } else {
        console.log('Is child');
      }
      <i>// В данном случае он учитывает все предыдущие условия и выполняет нужное</i>

      const age = 25;
      // <i>Второй формат:</i>
      if(age > 18) {
        console.log('Is adult');
      } 
      
      if(age >= 12) {
        console.log('Is teenager');
      } 
      
      if(age &#60; 12) {
        console.log('Is child');
      }
      // <i> В этом формате выполнятся два варианта условия и (age > 18) и (age >= 12) т.к. они оба правдивы </i>
    </code>
    <p class="text">Чтобы выполнилось только одно условие во втором варианте написание, нужно учесть предыдущее условие и дописать <span class="underline">(age >= 12 && age =&#60; 18)</span></p>
    <br>
    <p class="bold">Использование if в функциях:</p>
    <code class="code">
      const sumPositiveNumbers = (a, b) => {
        if(typeof a !== 'number' || typeof b !=='number') {
          return 'One of the arguments is not a number';
        }

        if(a &#60;= 0 || b &#60;= 0) {
          return 'Numbers are not positive';
        }

        return a + b;
      }
    </code>
    <br>
    <h5>Инструкция switch:</h5>
    <p class="underline">Это по сути альтернатива инструкции if...else if...else</p>
    <br>
    <p class="bold">Синтаксис switch:</p>
    <code class="code">
      switch (Выражение) {
        case A:
          // <i>Действия если Выражение === A</i>
          break;
        case B:
          // <i>Действия если Выражение === B</i>
          break;
        default:
          // <i>Действия по умолчанию</i>
      }
    </code>
    <br>
    <p class="bold">Пример switch:</p>
    <code class="code">
      const month = 2;

      switch (month) {
        case 12:
          console.log('Декабрь');
          break;

        case 1:
          console.log('Январь');
          break;

        case 2:
          console.log('Февраль');
          break;

        default:
          console.log('Это не зимний месяц');
      }
    </code>
    <br>
    <h5>Тернарный оператор:</h5>
    <p class="underline">У тернарного оператора три операнда.</p>
    <p class="text">
      Конструкция с тернарным оператором - это <span class="underline">выражение</span>, а выражение возварщает значение. Тернарный оператор можно использовать чтобы присвоить значение переменной.
    </p>
    <br>
    <p class="bold">Синтаксис тернарного оператора:</p>
    <code class="code">
      Условие ? Выражение 1 : Выражение 2

      // <i>Рекомендуемая запись:</i>
      Условие 
        ? Выражение 1 
        : Выражение 2
    </code>
    <p class="text">В примере выше, если Условие правдиво, тогда возвращается результат Выражения 1, если Условие ложно, тогда возвращается результат Выражения 2.</p>
    <br>
    <p class="bold">Пример 1:</p>
    <code class="code">
      const value = 11;

      value
        ? console.log('Условие истинно')
        : console.log('Условие ложно');
    </code>
    <br>
    <p class="bold">Пример 2:</p>
    <code class="code">
      const value1 = 11;
      const value2 = 25;

      value1 && value2
        ? myFunction1(value1, value2)
        : myFunction2();
    </code>
    <br>
    <p class="bold">Пример 2:</p>
    <code class="code">
      let value = 11;
      console.log(value >= 0 ? value : -value); // <i>11</i>

      value = -5;
      const res = value >= 0 ? value : -value;
      console.log(res); // <i>5</i>
    </code>
    <br>
  </section>
</section>
    <section class="container page _page" id="cycles" data-page="cycles">
  <h2>
    Циклы
  </h2>
  <section class="page__section">
    <p class="bold">Пример без цикла:</p>
    <code class="code">
      let i = 0;
      console.log(i);
      i++;
      console.log(i);
      i++;
      console.log(i);
      i++;
      console.log(i);
      i++;
      console.log(i);
      i++;
      // <i>Повторяющиеся действия</i>
      // <i>Аналогичные повторяющиеся действия придётся производить с объектами
        или массивами, если мы не используем циклы</i>
    </code>
    <br>
    <h5>Типы циклов:</h5>
    <ol class="list">
      <li>for</li>
      <li>for ... in ...</li>
      <li>while</li>
      <li>do ... while</li>
      <li>for ... of ...</li>
    </ol>
    <p class="text">Все циклы - это не выражения, а <span
        class="underline">инструкци</span>.</p>
    <br>
    <h5>Цикл for:</h5>
    <p class="bold">Синтаксис цикла for:</p>
    <code class="code">
      for (Начальная инструкция; Условие; Итерационное действие) {
      // <i>Блок кода, выполняемый на каждой итерации</i>
      }
    </code>
    <br>
    <p class="bold">Пример:</p>
    <code class="code">
      for (let i = 0; i &#60; 5; i++) {
        console.log(i);
      }
    </code>
    <p class="text">Цикл for можно использовать для массивов, но это не
      рекомендуется. Лучше использовать функции высшего порядка массивов -
      "forEach", "map", "reduce", т.к. они по сути являются родными функциями
      для работы с массивами. Поэтому не нужно усложнять.</p>
    <br>
    <p class="bold">Пример цикла for для массивов:</p>
    <code class="code">
      const myArray = ['first', 'second', 'third'];

      for (let i = 0; i &#60; myArray.length; i++) {
        console.log(myArray[i]);
      }
      // <i>'first'</i>
      // <i>'second'</i>
      // <i>'third'</i>
    </code>
    <br>
    <p class="bold">Тот же пример на forEach:</p>
    <code class="code">
      const myArray = ['first', 'second', 'third'];

      myArray.forEach((el, index) => {
        console.log(el, index);
      });
      // <i>'first' 0</i>
      // <i>'second' 1</i>
      // <i>'third' 2</i>
    </code>
    <br>
    <h5>Цикл while:</h5>
    <p class="bold">Синтаксис цикла while:</p>
    <code class="code">
      while (Условие) {
        // <i>Блок кода, выполняемый на каждой итерации, пока условие истинно</i>
      }
    </code>
    <br>
    <p class="bold">Пример цикла while:</p>
    <code class="code">
      let i = 0;

      while (i &#60; 5) {
        console.log(i);
        i++;
      }
    </code>
    <br>
    <h5>Цикл do while:</h5>
    <p class="bold">Синтаксис цикла do while:</p>
    <code class="code">
      do {
       // <i>Блок кода, выполняемый на каждой итерации</i>
      } while (Условие)
    </code>
    <p class="text">Цикл "do while" выполнится минимум один раз, потому что
      инструкция начинается с ключевого слова "do" после которого идет
      выполняемый Блок кода, и дальше после Блока кода находится условие. Т.е.
      мы говорим делать что-то пока Условие правдиво, но Условие находится после
      Блока кода, поэтому Блок кода выполнится минимум один раз.</p>
    <p class="underline">Если цикл "while" может быть не выполнен ни разу, то
      цикл "do{} while()" выполнится хотя бы один раз
    </p>
    <br>
    <p class="bold">Пример 1</p>
    <code class="code">
      let i = 0;

      do {
        console.log(i);
        i++;
      } while (i &#60; 5)
    </code>
    <br>
    <p class="bold">Пример 2</p>
    <code class="code">
      let i = 10;

      do {
        console.log(i);
        i++;
      } while (i &#60; 5)
      // <i>Данный блок кода выполнится только один раз</i>
    </code>
    <br>
    <h5>Цикл for in:</h5>
    <p class="bold">Синтаксис цикла for in:</p>
    <code class="code">
      for (key in Object) {
        // <i>Действия с каждым свойством объекта</i>
        // <i>Значения свойства - Object[key]</i>
      }
    </code>
    <p class="underline">Блок инструкций выполняется для каждого свойства объекта.</p>
    <br>
    <p class="bold">Пример 1</p>
    <code class="code">
      const myObject = {
        x: 10,
        y: true,
        z: 'abc'
      }

      for (const key in myObject) {
        console.log(key, myObject[key]);
      }
    </code>
    <br>
    <p class="bold">Пример 2</p>
    <p class="text">Использование forEach для перебора свойств объекта</p>
    <code class="code">
      const myObject = {
        x: 10,
        y: true,
        z: 'abc'
      }

      Object.keys(myObject).forEach(key => {
        console.log(key, myObject[key]);
      })
    </code>
    <br>
    <p class="bold">
      Пример с Object.keys(obj) и Object.values(obj):
    </p>
    <p class="text">
      <span class="underline">Object.keys(obj)</span> - получение всех ключей объекта в виде массива. <br>
      <span class="underline">Object.values(obj)</span> - получение всех значений свойств объекта в виде массива.
    </p>
    <code class="code">
      const myObject = {
        x: 10,
        y: true,
        z: 'abc'
      }

      const arrKeys = Object.keys(myObject);
      const arrValues = Object.values(myObject);

      console.log(arrKeys); // <i>['x', 'y', 'z']</i>
      console.log(arrValues); // <i>[10, true, 'abc']</i>
    </code>
    <br>
    <p class="bold">Пример использования for in для массивов:</p>
    <code class="code">
      const myArray = [true, 10, 'abc', null];

      for (const key in myArray) {
        console.log(myArray[key]);
      }
    </code>
    <br>
    <h5>Цикл for of:</h5>
    <p class="bold">Синтаксис цикла for of:</p>
    <code class="code">
      for (Element of Iterable) {
        // <i>Действия с определённым элементом</i>
      }
      // <i>Iterable - любое значение или переменная по которой можно итерироваться, т.е. элементы которой можно перебирать</i>
    </code>
    <br>
    <p class="bold">Пример for of для строк:</p>
    <code class="code">
      const myString = 'Hey';

      for (const letter of myString ) {
        console.log(letter);
      }
    </code>
    <br>
    <p class="bold">Пример for of для массивов:</p>
    <code class="code">
      const myArray = [true, 10, 'abc', null];

      for (const el of myArray) {
        console.log(el);
      }
    </code>
    <p class="underline">Для массивов всегда лучше использовать forEach</p>
    <br>
    <p class="bold">for of не для объектов:</p>
    <code class="code">
      let myObj = {
        x: 10, 
        y: true,
        z: 'abc'
      }

      for (const prop of myObj) {
        console.log(prop);
      }
      // <i>Uncaught TypeError: myObj is not iterable</i>
    </code>
    <p class="text">Объект не является итерируемым элементом, поэтому применение цикла "for of" на объекте выдаст ошибку. <br>
      <span class="underline">for of нельзя использовать для объектов.</span>
    </p>
  </section>
</section>
    <section class="container page _page" id="modules" data-page="modules">
  <h2>
    Модули
  </h2>
  <section class="page__section">
    <h4>Пример заголовка</h4>
    <code class="code">
      
    </code>
  </section>
</section>
  </main>
  <footer class="footer">
  <div class="container">
    <div class="footer__content">
      <p>Все права защищены. © «Eug Inc.», 2023</p>
    </div>
  </div>
</footer>
  
</body>

</html>