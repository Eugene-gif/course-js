<section class="container page _page" id="classes" data-page="classes">
  <h2>
    Классы и прототипы
  </h2>
  <br>
  <p class="bold">Синтаксис классов появился в ES6:</p>
  <code class="code">
    class ...
  </code>
  <p class="text">Раньше, до появления синтаксиса классов в JS экземпляры объектов создавались с помощью функций.</p>
  <p class="text"><b class="bold">Классы</b> позволяют создавать прототипы для объектов. 
    <br>На основании прототипов создаются <b class="bold">экземпляры</b>.
  <br>Каждый экземпляр может иметь свои собственные свойства и методы.
  <br><b class="bold">Экземпляры</b> наследуют свойства и методы прототипов.</p>
    <br>
  <p class="bold">Пример синтаксиса класса:</p>
  <code class="code">
    class Comment {
      constructor(text) {
        this.text = text;
        this.votesQty = 0;
        // <i>Переменная this указывает на экземпляр класса.</i>
      }

      upvote() {
        this.votesQty += 1;
      }
    }

    // <i>Создание экземпляра объекта</i>
    const firstComment = new Comment('First comment');
  </code>
  <br>
  <p class="bold">Проверка принадлежности:</p>
  <code class="code">
    class Comment {
      constructor(text) {
        this.text = text;
        this.votesQty = 0;
      }

      upvote() {
        this.votesQty += 1;
      }
    }

    const firtsComment = new Comment('First comment');

    firstComment instanceof Comment; // <i>true</i>
    firstComment instanceof Object; // <i>true</i>
    firstComment instanceof Array; // <i>false</i>
  </code>
  <br>
  <p class="bold">Вызов методов:</p>
  <code class="code">
    class Comment {
      constructor(text) {
        this.text = text;
        this.votesQty = 0;
      }

      upvote() {
        this.votesQty += 1;
      }
    }

    const firtsComment = new Comment('First comment');

    firstComment.upvote();
    console.log(firstComment.votesQty); // <i>1</i>
    firstComment.upvote();
    console.log(firstComment.votesQty); // <i>2</i>
  </code>
  <br>
  <code class="code">
    Comment.prototype.constructor === Comment // <i>true</i>
  </code>
  <br>
  <p class="underline">Объекты не наследуют методы массивов, также, как и массивы не наследуют методы объектов.</p>
  <br>
  <p class="bold">Проверка принадлежности свойств экземпляру объекта:</p>
  <code class="code">
    const firstComment = new Comment('First comment');

    firstComment.hasOwnProperty('text'); // <i>true</i>
    firstComment.hasOwnProperty('votesQty'); // <i>true</i>
    firstComment.hasOwnProperty('upvote'); // <i>false</i>
    firstComment.hasOwnProperty('hasOwnProperty'); // <i>false</i>
  </code>
  //<p class="text"><span class="underline">hasOwnProperty</span> - проверяет есть ли собственное сввойство у объекта. В примере выше проверка "upvote" выдаст "false", потому что "upvote" не является методом конкретного объекта "firstComment", а он наследуется от родительского класса "Comment".</p>
  <br>
  <p class="bold">Создание нескольких экземпляров:</p>
  <code class="code">
    class Comment {
      constructor(text) {
        this.text = text;
        this.votesQty = 0;
      }

      upvote() {
        this.votesQty += 1;
      }
    }

    const firstComment = new Comment('First comment');
    const secondComment = new Comment('Second comment');
    const thirdComment = new Comment('Third comment');
  </code>
  <p class="text"><span class="underline">firstComment, secondComment, thirdComment</span> - это разные объекты с разными собственными свойствами.</p>
  <br>
  <p class="bold">Статические методы:</p>
    <div class="img">
      <img src="src/img/images/classes-1.webp" alt="Статические методы">
    </div>
    <p class="underline">
      Статический метод "mergeComments" не будет доступен на уровне экземпляра класса "Comment"
    </p>
    <br>
    <p class="bold">Расширение других классов:</p>
    <div class="img">
      <img src="src/img/images/classes-2.webp" alt="Расширение других классов">
    </div>
    <p class="text">Родительский конструктор Array вызовется автоматически.</p>
    <p class="bold">Цепочка прототипов для примера выше:</p>
    <div class="img">
      <img src="src/img/images/classes-3.webp" alt="Цепочка прототипов">
    </div>
    <br>
    <h3>Что же такое прототип?</h3>
    <p class="text">У каждого экземпляра того или иного класса есть скрытое свойство "__proto__". Благодаря ему создаётся вся цепочка прототипов. И можно проверить, что свойство "prototype" конкретного класса будет равно свойству "__proto__" экземпляра этого класса.</p>
    <div class="img">
      <img src="src/img/images/classes-4.webp" alt="Пример">
    </div>
    <p class="text"><span class="bold">Прототип</span> - это объект, и в этом объекте находятся такие методы как конструктор и другие методы, которые вы определили в конкретном классе.</p>
    <p class="underline">Это всё создано для того, чтобы создать видимость, что JS - это объектно-ориентированный язык программрования, хотя на самом деле это не так. Но, благодаря прототипам и цепочке прототипов, которые являются простыми объектами на самом деле, мы создаём возможность наследования свойств и методов.</p>
    <br>
    <p class="bold">
      Строки и числа ведут себя как объекты:
    </p>
    <div class="img">
      <img src="src/img/images/classes-5.webp" alt="Пример">
    </div>
</section>